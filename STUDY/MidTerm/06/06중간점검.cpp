// 포인터에 대해 적용할 수 있는 연산은? ++ -- 등의 증감 연산.
// 간접 참조 연산?

// int형 포인터 p 가 80번지를 가리키고 있었다면, p+1 은? 84번지

// double형 배열을 가정하자. 2개의 더블 포인터 p, q 가 있고, p가 2번째 , q가 5번째 원소
// q - p 는? 2번째와 5번째 사이에는 3개의 double 공간이 존재하므로,
// 3 x double 1개당 바이트 = 3 x 8byte  = 24byte 이다.

// p 가 포인터라고 하면,  *p++ 와 (*p) ++ 의 차이점은? *p++ 는 주소값의 증가,
// (*p) 는 주소가 가리키는 값의 증가이다.

// *(p + 3) 의 의미는? p 주소를 3칸 (주소상으로 12) 옮긴 다음, 그 값을 구하는 것

// 배열의 첫 번째 원소의 주소를 계산하는 2 가지 방법.
// 1. 배열 이름을 작성 . 2. 배열 첫 번째 원소의 주소를 & 연산자로 호출

// 배열 a[] 에서 *a 의 의미는?
// 배열 a 의 첫 번째 원소의 실제 값

// 배열의 이름에 다른 변수의 주소를 대입할 수 있는가?
// NO

// 포인터를 이용하여 배열의 원소들을 참조할 수 있는가?
// YES

// 포인터를 배열의 이름처럼 사용할 수 있는가?
// 있다!

// 프로그램의 실행 도중에 메모리를 할당받아 사용하는 것 = 동적 할당법

// 동적으로 메모리를 할당받을 때는 new, 해제할 때는 delete를 사용한다.

// C++ 에서는 call-by-value / call-by-reference 두 가지로
// 인수를 전달한다.
// 이는 함수에게 값을 전달할 때의 방식의 차이이다.


// 함수에 매개변수로 변수의 복사본이 전달되는 것 = call by value
// 원본이 전달되는 것 = call by reference
// 배열을 함수로 매개 변수로 지정하면, 함수의 주소를 찾아오므로, call by reference
// 복사가 일어나지 않는다는 뜻 ㅎ
