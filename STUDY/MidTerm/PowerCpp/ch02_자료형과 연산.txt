CH02 자료형과 연산
차례
1. 변수와 상수
2. 변수의 이름짓기
3. 변수 선언
4. 정수형
5. 문자형
6. 부동 소수점형
7. 수식과 연산자의 개념
8. 산술 연산자
9. 관계 연산자
10. 논리 연산자
11. 조건 연산자
12. 연산자의 우선순위와 결합 규칙

1. 변수와 상수

변수란?
프로그램에는 반드시 데이터를 저장할 공간이 있어야 한다. 예를 들어 학생들의 성적의 평균을 계산하는 프로그램을 생각하여 보자.
각각의 학생들의 성적이 입력되면 프로그램의 어딘가에 저장해야만 평균을 계산할 수 있다. 변수는 데이터를 담아두는 상자와 같다고 생각
할 수 있다. 앞으로 변수들은 모두 상자로 그려질 것이다. 상자들은 식별을 위하여 이름표를 붙이기도 한다. 변수도 마찬가지여서
변수와 변수를 구별하기 위하여 이름을 붙여준다. 상자의 앞면에 표시되어 있는 i 가 변수의 이름이다.

상수
프로그램 안에서 데이터를 저장하는 공간은 크게 2가지 종류로 나눌 수 있다. 하나는 프로그램이 실행되는 동안 저장된 값이 변경될 수 있는
공간이다. 이것이 앞에서 설명하였던 변수이다. 변수는 한 번 값이 저장되었더라도 언제든지 다시 다른 값으로 변경이 가능하다.
반면에 값이 한 번 정해지면 값을 변경할 필요가 없는 데이터들도 있다. 예를 들어서 원의 면적을 계산하려면 원의 반지름을 제곱한 후에
원주율인 3.14를 곱해야 한다.

area = 3.14 * radius * radius;

여기서 3.14와 같은 데이터를 상수(constant) 라고 한다. 상수는 프로그램이 실행되는 동안에 값이 변경되지 않는다.
상수에 꼭 정수나 실수만 존재하는 것은 아니다. 변경되지 않는 문자열이나 문자들도 상수라고 한다. 예를 들면 아래의 문장에서
"Hello, World!" 라는 문자열도 실행 도중에 변하지 않으므로 상수이다.

자료형의 개념
프로그래밍에서 사용하는 데이터의 종류도 상당히 다양할 수 있다. 12와 같은 정수 데이터도 있을 것이고, 3.14와 같은
소수점을 가지는 실수 데이터, "Hello World!" 와 같은 문자열 데이터도 있다. 문제는 데이터의 종류에 따라서 필요한
메모리 공간의 크기가 다르다는 점이다. 정수 데이터는 비교적 작은 메모리 공간으로도 충분하겠지만 실수 데이터는
더 큰 공간을 필요로 한다. 따라서 저장하는 데이터의 종류에 따라서 변수의 종류를 다르게 하는 것이 메모리를 효율적으로
사용하게 한다.

데이터의 종류를 자료형 또는 데이터 타입이라고 한다. 변수는 일단 하나의 자료형으로 정의되면, 해당되는 종류의 데이터만
저장할 수 있다. 예를 들어 정수를 저장하기로 하고 생성된 변수는 정수만을 저장할 수 있다. 정수형 변수에 실수를 저장할 수는 없다.

자료형을 크게 나누면 정수형 intager type 과 문자형 character type, 부동 소수점형 floating-point type 으로
나눌 수 있다. 정수형은 정수 타입의 데이터를 저장할 수 있다. 문자형은 하나의 문자를, 부동 소수점형은 실수 타입의 데이터를 저장한다.

정수형
1. 부호있는 정수형 : short / int / long
2. 부호 없는 정수형 : unsigned short ...

문자형 : char / unsigned char
부동 소수점형 : float / double (더 길다)

mid 1 : 변수와 상수의 차이점은? : 프로그램 작동 중에 변경 가능한가
mid 2 : 변수와 자료형의 관계는? : 변수는 상자이며, 자료형은 상자에 넣을 수 있는 자료의 종류이다. 메모리
mid 3 : C++ 가 지원하는 자료형들을 메모리 크기순으로 나열하라.

2. 변수의 이름짓기

변수의 이름은 프로그래머가 마음대로 지을 수 있지만, 몇 가지의 규칙을 지켜야 한다. 변수의 이름이나 함수의 이름은 모두
식별자의 일종이다. 식별자 identifier 란 변수 이름, 함수 이름 등에 사용되어서 다른 것들과 식별할 수 있게 해주는 것이다.
마치 "홍길동", "김철수" 등의 이름이 사람을 식별하듯이, 프로그램 안에서 변수와 변수들을 구별시켜주는 역할을 한다.
식별자는 다음과 같은 규칙에 따라 만들어야 한다.

>식별자
식별자는 알파벳 문자와 숫자, 밑줄 문자로 이루어진다. 불행히도 아직까지 한글은 사용할 수 없다 /// 사용 가능하다!!
이름의 첫 번째 문자는 반드시 알파벳 또는 밑줄 문자 '_' 이어야 한다. 따라서 이름은 숫자로 시작할 수 없다.
대문자와 소문자를 구별하여 서로 다른 것으로 취급한다. 따라서 변수 index 와 Index, INDEX 는 모두 다른 변수이다.
C++ 언어의 키워드와 똑같은 이름은 허용되지 않는다.
변수의 길이에는 제한이 없다.

sum / _count / number_of_pictures / King3 : 유효
2nd_base / money# / best-student / double : 불가

>좋은 변수 이름
변수의 이름을 짓는 것은 상당히 중요한 작업 중의 하나이므로 신중하게 결정하고 시간을 투자하여야 한다.
변수의 이름을 지을 때는 변수의 역할을 가장 잘 설명하는 이름을 지어야 한다. 좋은 변수 이름은 전체 프로그램을
읽기 쉽게 만든다. 하지만 반대로 즉흥적으로 지은 이름을 사용하게 되면 나중에 프로그램을 읽기가 아주 힘들어진다.
예를 들면 연도와 달, 일을 나타내는데 i, j, k라고 이름을 짓는 것보다 year, month, date 라고 하면 프로그램이
읽기 쉬워질 것이다. 영어 단어만을 사용해야 하므로 한영 사전을 이용하여 한글을 영문으로 바꾸는 것도 좋은 아이디어이다.

여러 단어로 되어 있는 변수 이름을 나타내는 데에는 몇 가지의 방식이 존재한다. 먼저 가장 전통적인 방법은 bank_account
처럼 중간에 밑줄 문자를 사용하는 것이다. 두 번째 방법은 BankAccount 처럼 단어 첫 번째 글자를 대문자로 하는 것이다.
<< 나는 대문자 방식이 좋다 >>

참고사항
C++ 소스를 읽다 보면 상당히 난해한 변수 이름들이 등장한다. 변수의 이름 앞에 변수의 타입을 나타내는 접두사를 붙이는 경우가
있다. 예를 들면 nCount와 같으면 n은 Count변수가 정수임을 나타낸다. lpNext 같은 경우에는 lp는 long pointer를 의미한다.
변수 이름은 자신의 스타일에 맞고 일관성있게 지으면 된다.

참고사항
키워드는 C++ 에서 특별한 의미로 사용하기 위하여 예약해 놓은 이름이다. 예를 들면 정수형을 나타내는 int가 바로 키워드이다.

mid 1 : 변수 이름을 만들 때 지켜야 하는 규칙은?
mid 2 : 변수 이름의 첫 번째 글자로 허용되는 글자들은 어떤 글자인가? : 알파벳, 언더바, 한글
mid 3 : 고유한 의미를 가지고 있는 단어들을 무엇이라고 하는가? : 키워드


3. 변수 선언
변수는 사용하기 전에 반드시 미리 선언하여야 한다. 변수 선언이란 컴파일러에게 어떤 변수를 사용하겠다고 미리 알리는 것이다.
이것은 요리하기 전에 어떤 크기의 그릇들이 얼마나 필요한 지 미리 예상하여 준비해 놓는 것과 같다. 선언을 하게 되면
컴파일러는 변수의 자료형에 맞는 기억 공간을 미리 확보한다. 만일 변수를 선언하지 않고 사용하게 되면 컴파일 오류가 발생한다.

> 변수 선언 방법
변수를 선언하는 방법은 간단하다. 원하는 자료형을 쓰고, 이어서 변수 이름을 쓰면 된다. 변수 선언도 하나의 문장이므로
반드시 세미콜론으로 종료하여야 한다.

자료형 변수이름 ;

char c;
int i;
double interestRate ;

변수가 선언되면 변수의 값은 아직 정의되지 않은 상태가 된다. 변수를 선언과 동시에 값을 넣는 방법은 변수 이름 뒤에 할당
연산자 '='를 놓고 초기값을 적어 넣으면 된다. 이것을 변수의 초기화 initialization 이라고 한다.

char c = 'a';
int i = 7 ;
double interestRate = 0.05;

동일한 타입의 변수인 경우, 같은 줄에서 선언과 동시에 변수들을 초기화할 수 있다.

int height = 100, width = 200;
다만 다음과 같이 하는 것은 문법적으로 틀리지는 않지만 피하는 것이 좋다.

int height , width = 200;
위의 문장의 경우 height 는 초기화되지 않고 width 만 200으로 초기화된다. 잘못 생각하면 height 와 width 가
모두 200으로 초기화된다고 생각할 수 있다. 따라서 위의 문장은 금지.

mid 1 : x 와 y 를 int 형으로 선언하여 보라. x는 0으로, y는 1로 초기화된다.
int x = 0, y = 1;
mid 2 : 하나의 문장을 사용하여 변수 x 와 y를 int 형으로 선언하여 보라.
이미 함


4. 정수형

정수형은 가장 기본적인 데이터 타입으로 정수를 저장할 수 있다. 정수형에는 다음과 같은 자료형이 있다.
short : 2바이트 : 16비트 <= int : 4바이트 : 32비트 <= long : 4바이트 : 32비트

수학에서의 정수는 -3, -2, -1, 0, 1, 2, 3... 과 같은 한 가지 종류만 존재하지만, c++에는 메모리의
크기가 한정되어 있으므로 한 가지 타입으로 전체 정수를 나타낼 수는 없다. 따라서 정수에 할당되는 비트의 개수에 따라
몇 가지의 종류로 나뉜다.
short / int / long / unsigned short, int, long

C++ 에서는 왜 여러가지 타입의 정수형이 있을까? 즉, 왜 하나의 정수형만 사용하지 않을까? 그것은 용도에 따라 프로그래머가
선택하여 사용할 수 있게 하려는 것이다. 만약 8비트만을 사용해서 정수를 나타낸다면 -128 ~ 127 사이의 정수만 표현 가능하다.
비트 수를 늘리면 범위는 확대가 가능하지만, 메모리 공간을 더 많이 필요로 한다. 따라서 다양한 크기를 가지는 정수 자료형을
제공하여, 각자 필요에 따라 적당한 크기의 정수 자료형을 선택하여 사용하자는 취지이다.

정수형에는 short, int, long이 있고 이들은 정수를 저장하는데 사용하는 비트의 수가 다르다. short형은 16비트로 정수를
저장한다. long 형은 32비트를 사용한다. int형은 CPU가 한번에 읽어서 처리할 수 있는 비트의 크기와 관련이 있다. 최근 대부분의
컴퓨터에서는 32 비트 CPU를 사용한다. 따라서 일반적으로 int형은 32비트이다. 이들을 사용하여 변수를 정의하면 다음과 같다.

short grade;
int count;
long distance;

short형이 표현할 수 있는 정수의 범위는 어떻게 계산할 수 있을까? short형은 -2^15 32768 에서 2^15 -1 32767 까지의
정수를 표현할 수 있다. int 형은 약 -21억에서 +21억까지의 정수를 표현할 수 있다. 현재 자기가 사용하는 정수형의
크기가 얼마인지 알고 싶으면 climits 헤더 파일을 참고하면 된다. 여기에는 정수형들의 최대값과 최소값을 기호 상수로 정의해 놓았다.
예를 들어서 int의 최대값은 INT_MAX로, 최소값은 INT_MIN으로 알 수 있다.

Q&A
그렇다면 다양한 정수 타입 중에서 어떤 정수 타입을 사용해야 하는가?
만약 상당히 큰 값 (32767 이상 또는 -32767 이하)를 필요로 한다면 long형을 사용하는 것이 좋다.
만약 기억 공간을 줄여야 한다면 short 형을 사용하는 편이 유리하다. 일반적인 경우에는 int형을 사용한다.
만약 음수를 사용하지 않는다면 unsigned 형을 사용하는 편이 좋다. char형도 아주 작은 정수형으로 사용이 가능하나
득보다는 실이 많다. 왜냐하면 컴파일러가 char 형을 int형으로 변환하기 위하여 추가적인 코드를
집어넣어야 하기 때문이다. 또한 의도하지 않은 부호 확장이 이루어질 수 있다.

간단한 예제로 정수형 변수들을 선언해 보고 정수값들을 대입하여 보자.

> unsigned 와 signed 수식자

unsigned 와 signed 수식자는 정수형 앞에 올 수 있다. 3개의 정수형에 signed, unsighed 수식자를 붙일 수 있으므로
모두 6가지의 정수형 자료형이 만들어질 수 있다.  unsigned 는 변수가 음수가 아닌 값만을 나타낸다. 음수가 제외되면 같은
비트로 더 넓은 범위의 양수를 나타낼 수 있다는 장점이 있다. 예를 들어 원래의 short형은 ... ... 물론 절대로 음수가 될 수
없는 값을 표현하는 경우에만 사용하여야 한다.

signed키워드는 반대로 자료형이 음수도 가질 수 있음을 명백히 하는데 사용된다. 따라서 signed int와 int는 같은 의미이며
보통의 경우에는 생략된다. 몇 가지의 예를 아래에 보였다.

unsigned int speed ;
unsigned distance;
unsigned short players;
unsigned long second;

참고사항 : unsigned 라고 쓰면 unsigned int를 의미한다. 또한 short 형은 short int 로 쓸 수 있다.
마찬가지로 long 또한 long int로 쓸 수 있다.


> 오버플로우
int 형 변수가 나타낼 수 있는 정수의 범위가 제한되어 있기 때문에 조심해야할 사항이 있다. int형 변수를 이용하여
덧셈과 같은 산술 연산을 하는 경우, 산술 연산의 결과가 int형이 나타낼 수 있는 범위를 넘어갈 수 도 있다. 예를 들어서
다음과 같은 코드를 살펴보자.

short형의 변수에 최대값인 32767 을 저장한 후에 1을 증가시키면 어떻게 될까? 이 경우에는 32767에서 갑자기
-32768이 된다. unsigned short형의 변수인 경우에는 65535에서 0으로 넘어간다. 이런 경우를 오버플로우 overflow
라고 하며, 변수가 나타낼 수 있는 범위를 벗어난 숫자를 저장하려고 할 때 발생한다.

한계를 벗어나면 자동차의 주행 거리계처럼 다시 처음으로 돌아가서 시작한다.

정수형에서 오버플로우가 발생하더라도 컴파일러는 아무런 경고를 하지 않는다. 오버플로우가 발생하면 전체적으로 부정확한
결과가 계산될 것이다. 따라서 프로그래머가 스스로 오버플로우가 일어나지 않도록 주의해야 한다.

참고사항
64비트 CPU의 등장으로 c++에서도 64비트 정수형을 지원한다. 이 자료형은 long long 형이며, 이미 많은 컴파일러들이
지원하고 있다.

> 정수 상수
정수 상수는 12나 100과 같이 프로그램 안에 직접 입력하면 된다. 정수 상수는 기본적으로 int형으로 간주된다. 그러나 만약
int형의 범위를 넘는 정수 상수는 컴파일러가 long형으로 취급한다. 상수의 경우, 컴파일러가 자동으로 값을 저장할 수 있는
가장 작은 자료형을 선택하지만, 만약 자료형을 프로그래머가 명시하고 싶은 경우는 그렇게 할 수도 있다. 123L처럼 정수 상수
뒤에 접미사로 L을 붙이면 123이라는 상수를 long형으로 간주한다.

u 또는 U -> unsigned int
l 또는 L -> long
ul or UL -> unsigned long

정수 상수는 10진법 뿐만 아니라 8진법이나 16진법으로도 표기가 가능하다. 8진법으로 표기하려면 앞에 0을 붙이면 된다.
8진법 사우는 0에서 7까지의 숫자를 포함할 수 있다. 즉 10을 8진법으로 표기해보면 012가 된다.

012(8) = 1x8^1 + 2x8^0 = 10(10)

16진법은 0부터 9까지의 숫자, A부터 F까지의 글자를 사용하여 나타낸다. 16진법으로 정수 상수를 표기하려면 앞에 0x를
붙이면 된다. 예를 들어서 10을 16진수로 나타내면 0xa or 0xA 이다.

0xA(16) = 10 x 16^0 = 10(10);

알파벳의 대소문자는 구분하지 않는다. 즉, 0xa = 0xA. 수를 나타내는데 a나 b와 같은 문자를 사용하는 것이 생소할 수 있다.
하지만 하드웨어와 관련하여 비트 조작을 할 때는 10진법보다 16진법이 훨씬 사용하기가 편리하다. 2진수와 16진수는 상당한
관련이 있다. 16진수의 하나의 자리수는 4비트에 해당한다. 따라서 32비트나 64비트 등의 2진수 데이터를 16진수로 표기하면
알아보기 쉽게 된다.

0xFF0F = 1111 1111 0000 1111 이다.

만약 cout을 이용하여 8진수나 16진법으로 정수를 출력하려면 oct, hex와 같은 특별한 지정자를 사용하여야 한다. 예를 들어
y를 8진법으로 출력하려면 다음과 같이 한다.

cout << oct;
cout << y << '\n';

여기서 cout << oct; 는 콘솔에 아무 것도 표시하지 않는다. 다만 cout이 사용하는 진법을 10에서 8로 변경한다.

> 기호 상수
보통의 상수는 변수와는 달리 이름이 없다. 그러나 상수에도 이름을 붙일 수 있는 방법이 있다. 기호 상수 symbolic constant는
기호에 의하여 상수를 표현한 것이다. 월급에서 세금을 제외한 순수입을 계산하는 아래의 두 문장은 같은 의미이며 TAX_RATE가 0.15로
정의된 기호 상수이다.

income = salary - 0.15 * salary;
income = salary - TAX_RATE * salary;

기호 상수는 상수 값을 그대로 쓰는 방법에 비하여 몇 가지의 장점을 지닌다. 첫 번째 장점은 기호 상수를 사용하면 프로그램을 읽기
쉬워진다는 점이다. 문장 1에서는 0.15가 무엇을 의미하는지 쉽게 알 수 없다. 하지만 문장 2에서는 0.15가 세율이라는 것을
쉽게 알 수 있다. 기호 상수의 두 번째 장점은 프로그램이 동일한 상수를 여러 곳에서 사용하고 있는 경우에 상수 값의 변경을
쉽게 할 수 있다는 것이다. 위의 예에서 세율이 변경된 경우, 숫자를 사용했다면 프로그램에서 그 상수가 사용된 모든 곳을 찾아
값을 변경하여야 한다. 그러나 기호 상수를 사용했다면 기호상수의 정의만 변경하면 된다.

기호 상수를 사용하는 방법은 다음 두 가지가 있다.

> 1. # define 문장 사용

# define TAX_RATE 0.15

위와 같은 문장을 프로그램의 첫 부분에 둔다. 보통 # define 문장은 프로그램의 맨 첫 부분에 모여 있다.
# define 이 들어가는 문장은 보통 컴파일러가 동작하기 전에 전처리기 preprocessor 가 처리한다.
전처리기는 단순히 기호 이름 TAX_RATE 을 전부 찾아서 0.15로 바꾼다.

> 2. const 키워드 사용

const 를 변수 선언 앞에 붙이면 상수가 된다. 선언 시에 const 가 붙여진 변수는 일단 초기화 된 후에 그 값이
변경될 수 없다. 이 문장은 변수 선언과 같이 세미콜론으로 끝남을 주의하라.

const double TAX_RATE = 0.15;

위와 같은 문장을 선언하였으면 이제부터 0.15 대신 TAX_RATE 을 사용할 수 있다.

Q&A
일반적으로 const 키워드를 사용하여 상수를 만드는 편이 장점이 많다. 먼저 자료형도 지정할 수 있으므로 문법적인 여러 가지
검사도 가능하다. 또한 상수가 정의되는 범위를 변수와 같이 제한할 수 있다. 추가로 배열이나 구조체와 같은 복합 데이터 타입도
const를 사용할 수 있다.

mid 1 : 정수형에 속하는 자료형을 모두 열거하라 : int short long
mid 2 : 기호상수를 쓰는 이유 : 상수를 한 번에 관리 가능
mid 3 : 정수를 다양하게 나누어 사용하는 이유 : 메모리를 효율적으로 사용하기 위함
mid 4 : 부호가 없는 unsigned int에 음수를 넣으면? -> overflow? yes
mid 변수가 저장할 수 있는 한계를 넘어서는 값을 저장하면? -> overflow 구체적인 예로 short에
32768을 저장하면? -> -32768


5. 문자형
> 문자와 아스키코드

문자 character 는 한글이나 영어에서의 하나의 글자, 숫자, 기호 등을 의미한다. 문자는 컴퓨터에는 그다지 중요한 것이 아니지만
사람에게는 아주 중요하다. 거의 모든 정보가 문자를 통하여 전달되기 때문이다. 컴퓨터는 문자를 어떻게 표현할까? 컴퓨터는 모든 것을
숫자로 표현한다는 것을 우리는 알고 있다. 문자도 역시 숫자로 표현한다. 한 가지 예를 들면 A 는 숫자 65로, B 는 66으로 표현한다.
따라서 문자를 넣어두는 변수의 값이 65이면 그냥 A 가 저장되어 있는 것으로 생각하면 된다.

문자를 숫자로 나타내는 규격으로 아스키 ASCII American Standard Code for Information Interchange 가 존재한다.
아스키 코드는 0~127까지의 숫자를 이용하여 문자를 표현한다. 따라서 아스키 코드에서 인쇄 가능한 코드는 스페이스 문자부터 시작한다.
스페이스 문자는 32로 표현된다. 느낌표 문자 ! 의 코드는 33이다. 이런 식으로 1씩 증가시켜서 알파벳 문자들을 차례대로 표현한다. A
의 코드는 65이고, B는 66이다. a 는 97이고, b 는 98이다.

참고사항
char 형이 내부적으로는 정수를 저장하기 때문에 기술적으로 보면 정수형이라고 말할 수도 있다. 그러나 char 라는 단어가 붙은 것처럼
char 형은 문자를 저장하기 위하여 만들어졌기 때문에 이 책에서는 문자형으로 소개하였다.

> 문자 변수와 문자 상수
문자가 정수로 표현되므로 정수를 저장할 수 있는 자료형은 문자도 저장할 수 있다. 아스키 코드가 0에서 127까지의 숫자만을 이용하므로
8비트로 충분히 표현이 가능하다. 2^8 = 256개의 문자까지 나타낼 수 있다.

char code;

만약 이 char 형의 변수 code에 문자 A를 저장하려면 어떻게 해야 할까? 문자 A는 아스키코드 65로 표현되므로 code에 65를 할당하면
될 것이다. 하지만 숫자를 대입하는 것보다 더 편리한 방법이 있다. C에서는 문자A를 표현하려면 작은따옴표 '' 를 사용하여 'A'와 같이
나타낼 수 있다.

code = 'A';
'A'와 같이 작은따옴표로 감싸진 문자를 문자 상수 character constant 라고 한다. 컴파일러는 작은따옴표로 감싸진 문자 상수를
만나면 이것을 아스키 코드로 변환한다. 실제로 code를 10진수 형식으로 출력하여 보면 65가 출력됨을 확인할 수 있다.

C++가 문자를 아스키코드라는 정수로 저장하기 떄문에 개발자들은 문자를 아스키코드로 변환하거나 반대로 아스키 코드를 정수로 변환할
필요가 없다.

오류주의
만약 문자 상수를 작은따옴표를 쓰지 않고 다음과 같이 기술하면 오류다.
char code = A;
컴파일러는 A를 변수 이름으로 생각한다. 작은따옴표를 빠뜨리지 않도록 주의하자.

> 제어 문자.

우리는 문자에 작은따옴표를 붙여서 문자 상수를 만들 수 있었다. 그런데 아스키 코드표에는 제어 문자들도 함께 정의되어 있다.
제어 문자들은 인쇄될 수가 없고, 주로 콘솔이나 프린터를 제어할 목적으로 이용되는 문자들이다. 예를 들면 화면에 새로운 줄을 만드는
줄바꿈 문자와 화면에 탭을 나타내는 문자, 벨소리를 내는 문자, 백스페이스 문자 등이 제어 문자에 포함된 다. 그러다면 이들 제어 문자들도
작은 따옴표를 붙여서 문자 상수를 만들 수 있을까? 제어 문자들은 출력할 수 없기 떄문에 불가능하다.

제어 문자들을 프로그램 안에 표현하는 몇 가지의 방법이 존재한다. 가장 간단한 방법은 그냥 해당 아스키 코드값을 직접 사용하는 것이다.
예를 들면 컴퓨터에서 벨소리를 발생시키는 제어 문자는 아스키 코드값이 7이다. 따라서 컴퓨터에서 "삐" 하고 경고 벨소리가 나게 하려면 다음과
같이 하면 된다.
char beep = 7;
cout << beep;

이 방법은 가장 쉬운 방법이지만 아스키 코드값을 전부 암기하여야 한다. 더 쉬운 방법은 없을까? 한 가지 방법은 이스케이프 시퀀스
escape sequence를 이용해서 표현하는 방법이다. 이스케이프 시퀀스는 역슬래시 \ 와 의미를 나타내는 한 글자를 붙여서 기술된다.
우리가 지금까지 사용하여 왔던 \n 문자가 바로 이스케이프 시퀀스의 대표적인 예이다. \n 문자는 화면의 다음 라인의 시작 위치로 커서를 보내는
제어 문자이다. 이 줄바꿈 문자의 경우 \와 newline 을 의미하는 n 이 붙어 \n 으로 나타낸다. 줄바꿈 문자는 헤더 파일에 endl 로 정의도이ㅓ
있다. 수평탭의 경우 \와 탭(tab)을 나타내는 t를 붙여서 \t와 같이 나타낸다. 벨소리를 나게 하는 제어 문자는 \a로 나타낸다. 다음 표에서
이스케이프 시퀀스로 표기된 제어 문자들을 정리하였다.

널 문자 \0
백스페이스 ( 한 칸 뒤로 옮긴다 ) \b
수평탭 \t
줄바꿈 \n
캐리지 리턴 (현재 라인의 처음으로 옮긴다) \r
큰따옴표 \"
작은따옴표 \'
역슬래시 \\

예를 들어 프로그램에서 경고음을 내려면 다음과 같이 하면 된다.
char beep = '\a';
cout << beep;

이스케이프 시퀀스는 큰따옴표 문자를 화면에 나타내는데도 사용된다. 원래 큰따옴표는 문자열 (문자들이 모인 것)을 표시하는
역할을 한다. 그러나 만약 큰따옴표를 화면에서 나타내야 할 경우가 있다면 큰따옴표의 본래 의미를 벗어나 출력해야 한다.

참고사항
특수 문자 표기 방법을 이스케이프 시퀀스라고 부르는 이유는 역슬래시가 다음에 오는 문자의 의미를 본래의 의미에서 탈출
하도록 만들기 때문이다. \다음에 오는 문자는 원래의 의미인 글자가 아닌 특별한 명령을 의미한다.

> 정수형으로서의 char

char형은 사실은 8비트의 정수를 저장하는 자료형이다. 따라서 문자뿐만 아니라 작은 정수값도 저장할 수 있다.
char형에도 signed와 unsigned의 수식어를 사용할 수 있다. signed를 붙이면 확실하게 부호가 있는 자료형이 되고,
unsigned를 붙이면 부호가 없는 자료형이 된다.
