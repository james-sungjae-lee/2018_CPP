05 배열과 구조체

차례
1. 배열
2. 배열의 응용
3, 배열과 함수
4. 다차원 배열
5. 정렬
6. 탐색

학습 목표
배열의 개념을 학습한다.
배열의 선언과 초기화 방법을 학습한다.
일차원 배열에 대하여 살펴본다.
다차원 배열에 대하여 살펴본다.

지금까지 학습했던 변수는 하나의 값만을 저장할 수 있었다. 하지만 복잡한 응용 프로그램에서는
 많은 값을 한꺼번에 저장할 수 있는 저장 장소가 필요하다. 배열은 이런 목적으로 만들
 어진 자료형이다. 배열을 사용하면 한 번에 여러 개의 값을 저장할 수 있는 공간ㅇ르 할당받을 수 있다.
 배열은 자료를 저장하는 기본적인 구조 중의 하나이다.

1. 배열

> 배열이란?

먼저 왜 배열이 필요한지 살펴보자. 예를 들어 학생 10명의 성적 중에서 최고 성적을 계산한다고 가정하자.
최고 성적을 계산하려면 먼저 성적이 어딘가에 저장되어야 한다. 성적을 저장하는 한 가지 방법은 개별 변수
를 사용하는 방법이다. 즉, 학생이 10명이므로 다음과 같이 10개의 변수를 사용하는 것이다.

int s0, s1, s2 ... s9;

이 방법의 문제점은 학생 수가 많아지면 변수를 선언하고 관리하는 작업이 상당히 복잡해진다는 점이다.
학생이 1000명인 경우르 상상해보라. 이런 경우에 배열을 사용하면 효율적이고 간편하게 처리할 수 있다.

배열(array) 는 동일한 타입의 데이터가 여러 개 저장되어 있는 데이터 저장 장소이다. 배열 안에 들어있는
각각의 데이터들은 배열 이름에 번호(인덱스)를 붙여서 접근된다. 배열을 이용하면 여러 개의 값을 하나의
이름으로 처리할 수 있다. 따라서 배열은 대량의 데이터를 처리할 때 꼭 필요하다.
배열을 사용하려면 먼저 배열을 선언하여야 한다. 배열 선언을 통하여 컴파일러에게 배열의 원소 개수가 몇
개이고 각 원소의 자료형이 무엇인지를 알려야 한다.

int grade [10]
자료형 배열이름 배열 크기

각각의 원소들은 번호가 매겨져 있는데 번호는 0부터 시작한다. 즉, 첫 번째 원소의 번호는 0이고, 두 번째
원소는 1, 마지막의 원소 번호는 9가 된다. C++ 에서는 항상 배열의 원소 번호가 0부터 시작함을 명심해야 한다.

배열에 저장된 데이터들을 배열 원소(array element) 라고 한다. 배열의 원소는 번호가 붙어 있는데 이것을
인덱스(index) 또는 첨자(subscript) 라고 부른다. 배열의 이름이 s라면 배열 원소는 s[0], s[1]... 이다.
배열을 사용하면 각각의 원소는 인덱스값만 변경하면 접근할 수 있으므로 반복 루프에서 사용하기가 편리하다.

>> 참고사항
배열의 크기를 나타낼 때는 항상 상수를 사용하여야 한다. 변수를 배열의 크기로 사용하면 컴파일 오류가 된다.
또한 배열의 크기를 음수나 0, 실수로 하면 모두 컴파일 오류이다.

> 배열 원소 접근

배열의 원소를 접근하려면 배열의 이름에 대괄호를 하고 괄호 안에 번호를 적어주면 된다. 다음과 같은
문장은 배열의 5번째 위치에 있는 배열 원소에 80을 저장하는 문장이다.

grade [5] = 80;

배열 원소는 변수와 100% 동일하다. 따라서 값을 배열 원소에 저장할 수 있고, 배열 원소에 저장된 값을 꺼낼
수도 있다. 또한 변수나 수식 등이 인덱스로 사용될 수 있다.

grade[i] = 100

예제

프로그램 설명
기호 상수를 사용하여 학생들의 수를 나타내었다. 차후에 학생들의 수를 변경하려면 이 기호 상수의 정의만
변경하면 된다. 각 학생들의 성적을 저장할 크기가 5인 정수형 배열을 선언한다. 성적의 합계를 저장할 변수
sum 을 선언한다. sum 에는 성적들이 계속 더해지므로 초기값은 0이어야 한다.
for 루프를 반복하면서 사용자로부터 학생들의 성적을 입력받는다. 안내 메시지를 출력하고 한 학생의 성적을
입력받은 뒤 다시 안내 메시지가 출력된다. grade[i] 는 배열 grade 의 i번째 원소이다.
for 루프를 반복하면서 성적들을 전부 합하여 성적들의 합계를 구한다. 한 번의 반복마다 i번째 학생의
성적인 grade[i]가 sum에 더해진다. sum 의 값을 5로 나누어서 성적의 평균을 구해 출력한다.
sum 이 정수이므로 정수 나눗셈이 되고, 따라서 소수점 이하는 계산되지 않는다. 평균을 소수점까지 구하려면
부동 소수점 연산을 하여야 한다.

예제
크기가 10인 배열을 정의하고, 반복 구조를 사용하여 배열 원소의 값을 난수로 초기화하는 예제

>> 참고사항
보통 배열을 선언할 때는 배열의 크기를 const 지시자로 만들어진 기호 상수로 지정한다. 기호 상수로
배열의 크기를 지정하면 크기를 변경하기 쉽다.

> 배열의 초기화

배열은 어떻게 초기화를 할까? 배열은 여러 개의 변수가 모인 것이다. 따라서 초기값도 하나가 아니고
배열의 원소 개수만큼이 필요하다. 배열을 초기화하려면 값들의 리스트를 콤마로 분리하여 중괄호 {} 로
감싼 후에 이것을 배열을 선언할 때 대입해주면 된다.

int grade[10] = {10, 20, 30, ... 100}

위의 문장에서는 10개의 원소로 된 배열 grade 를 선언한다. 첫 번째 원소 grade[0] 는 10으로 초기화된다.
나머지 원소들도 차례로 값이 대입된다.

모든 배열 원소에 초기값을 부여하는 것이 원칙이다. 그러나 만약 초기값의 개수가 원소들의 개수보다 적은 경우에는
앞에 있는 원소들만 초기화된다. 나머지 원소들은 0으로 초기화된다.

만약 초기값이 전혀 주어지지 않은 지역 변수라면 일반 변수와 마찬가지로 아무 의미없는 쓰레기값이 들어간다.
초기화만 하고 배열을 비워둘 경우에는, 컴파일러가 자동으로 초기값들의 개수만큼 배열 크기를 잡는다.

예제 array2

> 인덱스의 범위

배열을 사용할 때 조심하여야 하는 부분이 인덱스의 범위이다. 인덱스가 배열의 크기를 벗어나게 되면 프로그램에 치명적인
오류를 발생시킨다. 컴파일러는 프로그래머가 유효 범위 안에 있는 인덱스를 사용하고 잇는지 확인해주지 않는다.
프로그래머는 인덱스가 범위를 벗어나지 않았는지 확인하고, 책임을 져야 한다. 예를 들어 다음을 보자.

int grade[10];

위에서 사용 가능한 범위는 0~9 이다. 하지만 다음처럼 작동시키면 어떻게 되는가?

cout << grade[10];

위의 문장은 컴파일 오류가 아니다. 따라서 컴파일도 되고, 실행도 된다. 그러나 배열 grade[] 는 크기가 10이므로
인덱스는 0~9 여야 한다. 따라서 grade[10] 은 쓰레기값이 출력될 것이다.
더욱 치명적인 경우는 다음과 같다.

grade[10] = 99;

이 경우에는 컴퓨터 시스템 자체가 중단되는 최악이 사태를 가져올 수도 있다. 왜냐하면 배열 범위를 벗어나는 인덱스를
사용하면 엉뚱한 메모리의 값을 변경하는 결과를 가져오기 때문이다.

> 배열의 복사
C++ 에서는 하나의 배열을 다른 배열로 통째로 대입하는 것을 허용하지 않는다.

int grade[SIZE];
int score[SIZE];

score = grade;

하나의 배열을 다른 배열로 복사하기 위해서는 각각의 원소를 복사해주어야 한다. 예를 들어서 배열 a를 배열 b로 복사하려면
반복 루프를 사용해 원소의 개수만큼 반복하면서 각각의 원소들을 복사해 주어야 한다.

예제 array_copy

프로그램 설명
크기가 5인 정수형 배열 a[]와 b[]가 선언되었다. 배열 a[] 는 초기화가 되어 있고, b[]는 초기화 되지 않았다.
배열a[] 를 배열 b[]로 복사해야 한다. 배열은 통째로 복사할 수 없으므로 for 를 사용해 하나씩 옮겨준다.

> 배열의 비교
하나의 배열 전체를 다른 배열 전체와 비교할 수 있을까? 즉 배열 a와 배열 b를 비교하려면 어떻게 하여야 하는가?
배열 이름만 가지고 비교하는 것은 올바른 결과를 생성하지 않는다.

배열의 이름은 배열이 저장된 메모리의 주소와 같다. 따라서 사실 1은 배열의 내용을 비교하는 것이 아니라, 각각의
배열이 저장된 메모리의 주소를 비교하는 것이다. 따라서 주소는 서로 다를 수밖에 없고 배열 원소들의 값이
일치해도 항상 같지 않다는 메시지가 출력된다.
a[i] 와 b[i] 가 같지 않으면 for 루프는 중단된다. 따라서 for 루프가 중단되지 않고 종료하였다는 것은
모든 배열 원소가 일치함을 의미한다.

> 동적 배열
이번 장에서 학습하는 배열은 정적인 배열이라 할 수 있다. 즉, 컴파일 시간에 배열의 크기가 결정되고 더 이상 변경이
불가능하다. C++ 에서는 실행 시간이 크기를 변경할 수 있는 동적인 배열도 제공한다. 이것은 벡터 vector 라고 불리며
STL 이라는 라이브러리로 제공된다. 동적 배열의 장점은 컴파일 시간에 배열이 저장하는 원소의 개수를 결정할 필요가 없다는
점이다. 동적 배열은 응용 프로그램의 필요에 따라서 자동적으로 그 크기가 조절된다. 또한 배열을 조작하는 많은 유틸리티
함수들이 함께 제공된다. 동적 배열은 18장에서 학습한다.

지금까지는 함수의 인자로 int, float, double 등만을 사용하였다. 인자는 함수를 호출한 곳에서
함수에 전달하는 값이다. 배열도 함수의 인자로 사용할 수 있을까? 배열을 함수의 인자로 전달할 수 있으면
많은 작업들을 함수로 작성하여 편리하게 사용할 수 있다. 예를 들어 배열을 인자로 받아서 배열에 들어 있는
숫자들을 정렬하는 함수로 만들 수 있다면 정렬이 필요할 때마다 이 함수를 호출하여 편리하게 사용할 수 있을 것이다.

함수도 물론 함수의 인자로 사용할 수 있다. 하지만 단순 변수와는 약간 그 의미가 다르다. 우리는 함수 호출시에
"값에 의한 호출" 이 이루어진다는 것을 알고 있다. call by value 란 함수를 호출할 때, 인자의 값이
매개 변수로 복사되어서 전달이 되는 것을 의미한다. 그러나 배열의 경우에는 단순한 call by value 가 아니다.
배열이 인자인 경우에는 복사되는 것이 아니고 배열의 원본이 매개 변수를 통하여 전달된다. 여기에 대한 설명은
포인터를 학습해야만 완전해진다. 지금으로는 그냥 배열의 원본이 전달된다고 알아두자.

먼저 함수가 배열을 매개 변수로 받기 위해서는 위의 문장과 같이 원형 선언과 함수 정의를 하여야 한다.
첫 매개 변수 int score[]가 배열을 나타낸다. 배열을 매개변수로 선언하는 경우에는 배열의 크기를 지정하지 않는다.
이유는 매개 변수로 배열을 선언하였어도 배열이 생성되는 것은 아니기 때문이다. 다만 매개 변수를 통하여 원본 배열을
참조만 할 수 있다. 따라서 정확한 크기는 필요하지 않다 . 단지 [] 기호를 통해 매개변수 score 가 배열이라는 것만 표시하면 된다.

>원본 배열의 변경
배열은 매개 변수를 통하여 원본을 참조하는 것이기 때문에 항상 조심해야 한다. 만약 함수 안에서 매개 변수를 통해 배열의
원소 값을 변경한다면, 이것은 원본 배열 grade 를 변경시키는 결과를 가져온다.

>참고사항
단순 변수를 인자로 함수를 호출하면 변수의 복사본이 전달되는 반면, 왜 배열만 원본을 공유할까? 여기는 몇 가지 이유가
있는데, 우선 보통 배열은 크기가 매우 클 수 있다는 것이다. 따라서 함수 호출을 할 때마다 배열을 인자에서 매개
변수로 복사하려면 많은 시간이 소요된다. 이것이 하나의 이유고, 또 하나의 이유는 호출된 함수들이 대개 배열을
조작하기 원한다는 것이다. 배열 매개 변수 전달 메커니즘의 이해는 포인터를 학습해야 완전해진다. 배열의 이름은
사실 배열이 저장된 메모리의 주소와 같다. 그러므로 배열을 전달하는 것은 배열의 주소를 전달하는 셈이다.

>원본 배열의 변경을 금지하는 법

배열이 함수의 매개 변수로 전달되는 경우, 함수 안에서 배열 원소들의 값을 변경할 수 있다.
가끔은 프로그래밍 실수로 인하여 의도하지 않았는데도 배열 원소의 값이 변경되는 경우가 발생한다.
이것을 방지하기 위해 앞에서 학습하였던 const 지정자를 사용할 수 있다.
일반적으로 const 지정자를 변수 앞에 붙이게 되면 변수가 상수로 변경된다. const 지정자를 붙이는
것은 기호 상수를 생성하는 방법 중의 하나였다. 간단한 사용 예를 보면 다음과 같다.

int get_average(const int grade[]){}

이렇게 배열을 불러오면 배열의 원소 변경이 불가능하다.

예제 : 05_copyArray.cpp

4. 다차원 배열

1차원 배열은 배열 원소들이 1차원적으로 배열되어 있다. 다차원 배열은 배열 원소를 다차원으로 가질 수 있다.
다차원 배열에는 2차원, 3차원 등 일반적으로 n 차원 배열이 가능하다. 제한이 없다.

> 2차원 배열
예를 들어 어떤 학교에 학급이 3학급이 있고, 각 학급의 학생 수가 5명이라고 가정하자. 이를 가장 간편하게 나타내려면
2차원 배열을 사용해야 한다. 크기가 3 x 5 인 2차원 배열을 선언하면 각 학급의 학생별 성적을 나타낼 수 있다.

int s[3][5];

위의 배열은 s[0][0] 부터 s[2][4] 까지 모두 15개의 원소를 가진다. 첫 번째 인덱스를 행번호라고 하고
두 번째 인덱스를 열번호라고 한다. 행 row 와 열 column 으로 이야기를 하면 배열 s 는 3개의 row 와
5개의 column 으로 이루어졌다.
2차원 배열은 바둑판과 같은 격자로 생각하는 것이 편리하지만, 사실 컴퓨터 메모리는 1차원적인 구조이다.
컴퓨터의 메모리는 바이트들이 1차원적으로 나열되어 있는 구조이다. 따라서 메모리에는 일렬로 저장된다.
먼저 첫 번째 행에 속하는 원소들이 할당되고, 다음에 두 번째 등으로 나열된다. 이런 방식을 행우선
row- major 방식이라고 한다. 자세히 보면 2차원 배열은 1차원 배열의 배열로 생각할 수 있다.
즉 각각의 행은 1차원 배열로 이루어져 있다.

각 배열 원소에 할당되는 메모리는 원소들의 자료형에 따라 달라진다. 만약 int 형 배열이라면 각 원소당
4바이트가 할당될 것이고, double 형 배열이라면 각 원소당 8바이트가 할당될 것이다. 배열 s[][]는 int
형이므로 전체 배열이 차지하는 메모리의 크기는 4 x 3 x 5 = 60 바이트가 된다.
3 x 5 크기의 정수형 2차원 배열 s[] 를 정의하고 이 배열 원소에 0 부터 14까지의 수를 저장하고 출력하는
간단한 프로그램을 작성하여 보자.

2차원 배열은 2중 루프를 이용하여 데이터를 처리하게 된다.


> 2차원 배열의 초기화
2차원 배열도 1차원과 마찬가지로 선언과 동시에 초기화할 수 있다. 다만 같은 행에 속하는 초기값들을
중괄호 {} 로 따로 묶어주어야 한다.
int s[3][5] = {
{0, 1, 2, 3, 4,},
{10, 11, 12, 13 ,14},
{20, 21, 22, 23, 24}
};

같은 행에 속하는 초기값들은 하나의 집합으로 중괄호로 묶여진다. 전체 배열에 대한 초기값은 이들 집합 모두를 중괄호로
한 번 더 묶으면 된다. 각 초기값들은 쉼표로 구분된다. 각 행의 초기값들의 집합들도 쉼표로 구분된다.

만약 선언과 동시에 초기화하는 경우, 행의 개수는 지정하지 않을 수 있다. 이 경우 컴파일러가 자동으로
행의 개수를 결정한다. 반면 반드시 열의 개수는 지정하여야 한다.

int s[][5] = {
{1, 2, 3, 4, 5}
}

초기값을 지정하지 않는 경우에는 변수가 어디에 선언되어 있느냐에 따라서 달라진다. 만약 전역 변수로 선언되어
있는 경우에는 컴파일러가 나머지 원소들의 값을 0으로 초기화하다. 따라서 아래와 같이 선언되면 s[1][3] 등은
0으로 초기화된다.

int s[][5] = {
{0, 1, 2}
};

하지만 배열이 지역 변수로 선언되어 있는 경우에는 쓰레기값이 들어가게 된다. 따라서 이 경우에는 반드시
초기화를 시켜 주어야 한다.
만약 중괄호를 사용하여 각 행들을 분리하지 않으면 행의 크기에 맞추어 자동적으로 행으로 분리되어 초기화한다.
